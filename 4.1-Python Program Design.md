In this course, I mainly learned Python basic syntax, data structures (such as lists and dictionaries), control flow (conditionals and loops), function definition and calling, and file reading and writing operations. 

This is a highly practical, lab-based course designed to help us master fundamental Python programming skills and pass **the National Computer Rank Examination Level 2** in Python. We had weekly hands-on lab sessions where we wrote real code to understand each concept. Our teacher emphasized practice and debugging rather than rote memorization.

## Basic Syntax

Python basic syntax was the starting point of this course, just like learning the alphabet and vocabulary when studying English. We first learned how to define and assign variables—for example, using `x = 5` to represent an integer variable, or `name = "Alice"` for a string. Then we studied data types such as integers (int), floating-point numbers (float), strings (str), and Boolean values (True/False). We also learned how to use the `print()` function to display information—for instance, `print("Hello, world!")` shows a message on the screen. Additionally, we learned to use the `input()` function to get input from the user—for example, writing a program that asks “What is your name?” and stores the user’s input. These are the most basic operations, but they are essential because all more complex programs are built on top of them.

## Data Structures

In the data structures section, we focused on lists and dictionaries. A list is like a shopping list that can hold many items—for example, `fruits = ["apple", "banana", "orange"]`. We can access elements using an index, so `fruits[0]` gives us the first item, "apple". We also learned how to add, remove, modify, and search items in a list—for example, using `fruits.append("grape")` to add a new fruit, or `fruits.remove("banana")` to remove banana. A dictionary is more like a phone book—it pairs a "name" with a "number", such as `phone_book = {"Alice": "12345", "Bob": "67890"}`. We can quickly look up a number by name—for example, `phone_book["Alice"]` returns "12345". In one lab exercise, we used a dictionary to store students’ names and their scores, then calculated the average. For example, given {"Tom": 85, "Lily": 92, "Jack": 78}, we used `sum(scores.values()) / len(scores)` to compute the average score, which is 85. This kind of structure is very useful when handling real-world data.

## Control Flow

Control flow is what makes programs "smart". We learned conditional statements (if-else), which are like multiple-choice questions in real life. For example, we wrote a program to judge whether a student's score is excellent, good, or failing: if the score is 90 or above, print "excellent"; if it's between 80 and 89, print "good"; otherwise, print "failing". The code looks something like this:
```python
score = 85
if score >= 90:
    print("Excellent")
elif score >= 80:
    print("Good")
else:
    print("Failing")
```
We also learned loop structures, such as for loops and while loops. A for loop is good for tasks with a known number of repetitions—for example, printing each number from 1 to 5:
```python
for i in range(1, 6):
    print(i)
```
A while loop is better for tasks that may end at an uncertain time—for example, letting a user keep guessing a number until they get it right. In one lab, we wrote a program that randomly generates a number between 1 and 10—say, 7—and asks the user to guess it. If the guess is too low, it says "Too low!"; if too high, "Too high!"; and it keeps going until the user guesses correctly. These structures allow the program to respond differently to different inputs instead of doing the same thing every time.

## Functions

Functions are like putting a piece of reusable code into a "toolbox" so you can use it later by simply calling its name. For example, we defined a function to calculate the area of a circle:
```python
def calculate_area(radius):
    return 3.14159 * radius ** 2
```
After that, writing `calculate_area(5)` gives us the area of a circle with radius 5, which is about 78.54. The benefit is that we don’t have to write the same code over and over, and the program becomes easier to read. In one lab, we built a small student grade management program with several functions: one to add a student’s score, one to look up a score, and one to calculate the average. For example, calling `add_score("Mike", 88)` would add Mike’s score to the system. This way, the whole program is like building with LEGO blocks—each function is a block, and when combined, they can accomplish complex tasks.

## File Reading and Writing

Finally, we learned file reading and writing, which allows us to save data permanently instead of re-entering everything every time the program runs. For example, we use `open("scores.txt", "w")` to create a text file and write data into it, such as:
```python
with open("scores.txt", "w") as f:
    f.write("Tom: 85\nLily: 92\nJack: 78")
```
The next time the program runs, we can use `open("scores.txt", "r")` to read this data back and continue processing. It’s like keeping a diary—what you write today can still be read tomorrow. In exams, we often get questions that require reading data from a file and performing calculations, such as computing the average or finding the highest score, so mastering this skill is essential.