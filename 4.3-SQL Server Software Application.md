In this course, I mainly learned about database creation and management, table design and data integrity constraints, SQL query language (especially the SELECT statement), data manipulation operations (INSERT, UPDATE, DELETE), and the basic use of views. These topics form the core of the SQL Server software application lab course and helped me master how to store, organize, and retrieve information within a real database management system.

## Database Creation and Management

In this course, I mainly learned about database creation and management, which is about how to set up an "electronic warehouse" in the SQL Server software to store data. You can think of a database as a large electronic filing cabinet that can hold many tables, each table being like an Excel sheet used to record different types of information. 

For example, in one experiment, we created a database named "StudentDB" specifically to manage student information. We used SQL Server Management Studio (a graphical tool, like a control panel for the database) to create this database and set its initial size, auto-growth settings, and storage path. For instance, we allocated an initial size of 5MB, and when more data was added, it would automatically grow by 1MB each time. This process is like laying the foundation of a new room, deciding its size, and determining whether the room should expand automatically when more people come in. Through this exercise, I learned how to plan and initialize a database environment for different application scenarios.

## Table Design and Data Integrity Constraints

In this course, I mainly learned about table design and data integrity constraints, which is about how to create specific tables inside a database and ensure that the data stored is accurate, consistent, and meaningful. A table is the most basic storage unit in a database. 

For example, we can create a table called "Students" with columns like StudentID, Name, Age, and Gender. When designing this table, we not only define the data type for each column (e.g., StudentID is an integer, Name is text), but also set rules to prevent incorrect data from being entered. For instance, we set "StudentID" as the primary key, meaning each student's ID must be unique—no duplicates and no empty values. This is like giving every person a unique ID number—no two people can have the same one. Additionally, we applied a check constraint on the "Age" column to ensure the age is between 15 and 60. If someone tries to enter "200", the system will reject it. Another important concept is the foreign key. For example, we have a "Courses" table to record courses and an "Enrollments" table to record which students enrolled in which courses. In the "Enrollments" table, we set a foreign key that references the "StudentID" in the "Students" table. This ensures that only real, existing students can be recorded in the enrollment table. These constraints help maintain data integrity and reliability.

## SQL Query Language

In this course, I mainly learned about the SQL query language, especially the SELECT statement, which is about how to "ask questions" and retrieve the information we want from database tables. The SELECT statement is like a powerful search engine that allows us to quickly find specific data from thousands or even millions of records. 

For example, in the "Students" table, if we want to know the names of all students older than 20, we can write an SQL statement: `SELECT Name FROM Students WHERE Age > 20;`. This means "select the Name column from the Students table where the Age is greater than 20". After execution, the system returns the list of students who meet the condition. We also learned more complex queries, such as using JOIN operations to combine two tables. For instance, if we want to know which courses a student has taken, we need to join the "Students" table with the "Enrollments" table, and then with the "Courses" table. We wrote a statement like this: `SELECT s.Name, c.CourseName FROM Students s JOIN Enrollments e ON s.StudentID = e.StudentID JOIN Courses c ON e.CourseID = c.CourseID WHERE s.Name = 'Zhang San';`. This statement is like a treasure map: first find Zhang San's student ID, then look in the enrollment table to see which course IDs he has, and finally go to the courses table to find the names of those courses. Through these exercises, I learned how to flexibly combine data to answer complex business questions.

## Data Manipulation Operations

In this course, I mainly learned about data manipulation operations—INSERT, UPDATE, and DELETE statements—which are about how to add, modify, and remove data in a database. These operations are like performing daily maintenance on a dynamic electronic spreadsheet. 

For example, when a new student enrolls, we need to add their information to the "Students" table using an INSERT statement: `INSERT INTO Students (StudentID, Name, Age, Gender) VALUES (1001, 'Li Si', 19, 'Male');`. This successfully enters Li Si's information into the system. If later we find that Li Si's age was recorded incorrectly—say, it should be 20 instead of 19—we can use the UPDATE statement to correct it: `UPDATE Students SET Age = 20 WHERE StudentID = 1001;`. The WHERE clause here is crucial—it ensures we only update Li Si's record, not change every student's age to 20. Similarly, if a student drops out, we can use the DELETE statement to remove them: `DELETE FROM Students WHERE StudentID = 1001;`. However, in practice, we are very cautious because deletion is irreversible. So, we usually back up the data first, or use "logical deletion"—for example, adding an "IsDeleted" flag column instead of physically removing the record. These operations taught me that a database is not just for storing data, but also for dynamically managing it.

## Virtual Table

In this course, I mainly learned about the basic use of views, which is about how to create a "virtual table" to simplify complex queries or protect sensitive data. A view doesn't actually store data; instead, it saves a SELECT query statement, and every time it's used, the query is executed again to return the latest data. 

For example, we created a view called "StudentCourseView" with the definition being the three-table JOIN query mentioned earlier: `CREATE VIEW StudentCourseView AS SELECT s.Name, c.CourseName FROM Students s JOIN Enrollments e ON s.StudentID = e.StudentID JOIN Courses c ON e.CourseID = c.CourseID;`. After creation, whenever we want to know which courses a student has taken, we no longer need to write that long JOIN statement every time. Instead, we can simply write: `SELECT * FROM StudentCourseView WHERE Name = 'Zhang San';`. This is like packaging a complex operation into a shortcut for easy reuse. Additionally, views can be used to restrict data access. For instance, if the school finance department can only see students' payment status but not their home addresses, we can create a view for them that includes only necessary fields, and then grant them access only to this view, not the entire "Students" table. This way, we meet business needs while protecting privacy. Through this topic, I learned how to use views to improve query efficiency and data security.